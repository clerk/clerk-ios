//
//  SignInFactorCodeView.swift
//  Clerk
//
//  Created by Mike Pitre on 4/21/25.
//

#if os(iOS)

import FactoryKit
import SwiftUI

struct SignInFactorCodeView: View {
    @Environment(\.clerk) private var clerk
    @Environment(\.clerkTheme) private var theme
    @Environment(\.authState) private var authState

    @State private var code = ""
    @State private var error: Error?
    @State private var remainingSeconds: Int = 30
    @State private var timer: Timer?
    @State private var verificationState = VerificationState.default
    @State private var otpFieldState: OTPField.FieldState = .default
    @FocusState private var otpFieldIsFocused: Bool

    let factor: Factor
    var isSecondFactor: Bool = false

    var signIn: SignIn? {
        clerk.client?.signIn
    }

    enum VerificationState {
        case `default`
        case verifying
        case success
        case error(Error)

        var showResend: Bool {
            switch self {
            case .default, .error:
                true
            case .verifying, .success:
                false
            }
        }
    }

    var showResend: Bool {
        switch factor.strategy {
        case "totp":
            return false
        default:
            return verificationState.showResend
        }
    }

    var showUseAnotherMethod: Bool {
        switch factor.strategy {
        case "reset_password_email_code", "reset_password_phone_code":
            false
        default:
            true
        }
    }

    var title: LocalizedStringKey {
        switch factor.strategy {
        case "email_code":
            "Check your email"
        case "phone_code":
            "Check your phone"
        case "reset_password_email_code", "reset_password_phone_code":
            "Reset password"
        case "totp":
            "Two-step verification"
        default:
            ""
        }
    }

    var subtitleString: LocalizedStringKey {
        switch factor.strategy {
        case "reset_password_email_code":
            "First, enter the code sent to your email address"
        case "reset_password_phone_code":
            "First, enter the code sent to your phone"
        case "totp":
            "To continue, please enter the verification code generated by your authenticator app"
        default:
            if let appName = clerk.environment.displayConfig?.applicationName {
                "to continue to \(appName)"
            } else {
                "to continue"
            }
        }
    }

    var resendString: LocalizedStringKey {
        if remainingSeconds > 0 {
            "Resend (\(remainingSeconds))"
        } else {
            "Resend"
        }
    }

    private func lastCodeSentAtKey(_ signIn: SignIn) -> String {
        signIn.id + (factor.safeIdentifier ?? UUID().uuidString)
    }

    var body: some View {
        ScrollView {
            VStack(spacing: 0) {
                VStack(spacing: 8) {
                    HeaderView(style: .title, text: title)
                    HeaderView(style: .subtitle, text: subtitleString)

                    if let identifier = factor.safeIdentifier {
                        Button {
                            authState.path = []
                        } label: {
                            IdentityPreviewView(label: identifier.formattedAsPhoneNumberIfPossible)
                        }
                        .buttonStyle(.secondary(config: .init(size: .small)))
                        .simultaneousGesture(TapGesture())
                    }
                }
                .padding(.bottom, 32)

                VStack(spacing: 24) {
                    OTPField(
                        code: $code,
                        fieldState: $otpFieldState,
                        isFocused: $otpFieldIsFocused
                    ) { code in
                        await attempt()
                    }
                    .onAppear {
                        verificationState = .default
                        otpFieldIsFocused = true
                    }

                    Group {
                        switch verificationState {
                        case .verifying:
                            HStack(spacing: 4) {
                                SpinnerView()
                                    .frame(width: 16, height: 16)
                                Text("Verifying...", bundle: .module)
                            }
                            .foregroundStyle(theme.colors.textSecondary)
                        case .success:
                            HStack(spacing: 4) {
                                Image("icon-check-circle", bundle: .module)
                                    .foregroundStyle(theme.colors.success)
                                Text("Success", bundle: .module)
                                    .foregroundStyle(theme.colors.textSecondary)
                            }
                        case .error(let error):
                            ErrorText(error: error)
                        default:
                            EmptyView()
                        }
                    }
                    .font(theme.fonts.subheadline)

                    if showResend {
                        AsyncButton {
                            await prepare()
                        } label: { isRunning in
                            HStack(spacing: 0) {
                                Text("Didn't recieve a code? ", bundle: .module)
                                Text(resendString, bundle: .module)
                                    .foregroundStyle(
                                        remainingSeconds > 0
                                            ? theme.colors.textSecondary
                                            : theme.colors.primary
                                    )
                                    .monospacedDigit()
                                    .contentTransition(.numericText(countsDown: true))
                                    .animation(.default, value: remainingSeconds)
                            }
                            .overlayProgressView(isActive: isRunning)
                            .frame(maxWidth: .infinity)
                        }
                        .buttonStyle(
                            .secondary(
                                config: .init(
                                    emphasis: .none,
                                    size: .small
                                )
                            )
                        )
                        .disabled(remainingSeconds > 0)
                        .simultaneousGesture(TapGesture())
                    }

                    if showUseAnotherMethod {
                        Button {
                            if isSecondFactor {
                                authState.path.append(
                                    AuthView.Destination.signInFactorTwoUseAnotherMethod(
                                        currentFactor: factor
                                    )
                                )
                            } else {
                                authState.path.append(
                                    AuthView.Destination.signInFactorOneUseAnotherMethod(
                                        currentFactor: factor
                                    )
                                )
                            }
                        } label: {
                            Text("Use another method", bundle: .module)
                        }
                        .buttonStyle(
                            .primary(
                                config: .init(
                                    emphasis: .none,
                                    size: .small
                                )
                            )
                        )
                        .simultaneousGesture(TapGesture())
                    }
                }

                SecuredByClerkView()
                    .padding(.top, 32)
            }
            .padding(16)
        }
        .scrollDismissesKeyboard(.interactively)
        .clerkErrorPresenting($error)
        .background(theme.colors.background)
        .taskOnce {
            startTimer()
            if let signIn, authState.lastCodeSentAt[lastCodeSentAtKey(signIn)] == nil {
                await prepare()
            }
        }
    }
}

extension SignInFactorCodeView {

    func startTimer() {
        updateRemainingSeconds()
        self.timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { _ in
            Task { @MainActor in
                updateRemainingSeconds()
            }
        }
        RunLoop.current.add(timer!, forMode: .common)
    }

    func updateRemainingSeconds() {
        guard let signIn, let lastCodeSentAt = authState.lastCodeSentAt[lastCodeSentAtKey(signIn)] else {
            return
        }

        let elapsed = Int(Date.now.timeIntervalSince(lastCodeSentAt))
        remainingSeconds = max(0, 30 - elapsed)
    }

    func prepare() async {
        code = ""
        verificationState = .default

        guard let signIn else {
            authState.path = []
            return
        }

        do {
            switch factor.strategy {
            case "email_code":
                try await signIn.prepareFirstFactor(
                    strategy: .emailCode(emailAddressId: factor.emailAddressId)
                )
            case "phone_code":
                if isSecondFactor {
                    try await signIn.prepareSecondFactor(
                        strategy: .phoneCode
                    )
                } else {
                    try await signIn.prepareFirstFactor(
                        strategy: .phoneCode(phoneNumberId: factor.phoneNumberId)
                    )
                }

            case "reset_password_email_code":
                try await signIn.prepareFirstFactor(
                    strategy: .resetPasswordEmailCode(emailAddressId: factor.emailAddressId)
                )

            case "reset_password_phone_code":
                try await signIn.prepareFirstFactor(
                    strategy: .resetPasswordPhoneCode(phoneNumberId: factor.phoneNumberId)
                )
            default:
                break
            }

            authState.lastCodeSentAt[lastCodeSentAtKey(signIn)] = .now
            updateRemainingSeconds()
        } catch {
            otpFieldIsFocused = false
            self.error = error
            ClerkLogger.error("Failed to prepare factor for sign in", error: error)
        }
    }

    func attempt() async {
        guard var signIn else {
            authState.path = []
            return
        }

        otpFieldState = .default
        verificationState = .verifying

        do {
            switch factor.strategy {
            case "email_code":
                signIn = try await signIn.attemptFirstFactor(strategy: .emailCode(code: code))
            case "phone_code":
                if isSecondFactor {
                    signIn = try await signIn.attemptSecondFactor(strategy: .phoneCode(code: code))
                } else {
                    signIn = try await signIn.attemptFirstFactor(strategy: .phoneCode(code: code))
                }
            case "reset_password_email_code":
                signIn = try await signIn.attemptFirstFactor(strategy: .resetPasswordEmailCode(code: code))
            case "reset_password_phone_code":
                signIn = try await signIn.attemptFirstFactor(strategy: .resetPasswordPhoneCode(code: code))
            case "totp":
                signIn = try await signIn.attemptSecondFactor(strategy: .totp(code: code))
            default:
                throw ClerkClientError(message: "Unknown code verification method. Please use another method.")
            }

            otpFieldIsFocused = false
            verificationState = .success
            authState.setToStepForStatus(signIn: signIn)
        } catch {
            otpFieldState = .error
            verificationState = .error(error)

            if let clerkError = error as? ClerkAPIError, clerkError.meta?["param_name"] == nil {
                self.error = error
                ClerkLogger.error("Failed to attempt factor for sign in", error: error)
                otpFieldIsFocused = false
            }
        }
    }

}

#Preview("Email Code") {
    Container.shared.signInService.preview { @MainActor in
        .init(
            prepareFirstFactor: { _, _, _ in
                try! await Task.sleep(for: .seconds(1))
                return .mock
            },
            attemptFirstFactor: { _, _ in
                try! await Task.sleep(for: .seconds(1))
                return .mock
            }
        )
    }

    SignInFactorCodeView(factor: .mockEmailCode)
        .environment(\.clerk, .mock)
}

#Preview("Phone Code") {
    Container.shared.signInService.preview { @MainActor in
        .init(
            prepareFirstFactor: { _, _, _ in
                try! await Task.sleep(for: .seconds(1))
                return .mock
            },
            attemptFirstFactor: { _, _ in
                try! await Task.sleep(for: .seconds(1))
                return .mock
            }
        )
    }

    SignInFactorCodeView(factor: .mockPhoneCode)
        .environment(\.clerk, .mock)
}

#Preview("Reset Password Email Code") {
    Container.shared.signInService.preview { @MainActor in
        .init(
            prepareFirstFactor: { _, _, _ in
                try! await Task.sleep(for: .seconds(1))
                return .mock
            },
            attemptFirstFactor: { _, _ in
                try! await Task.sleep(for: .seconds(1))
                return .mock
            }
        )
    }

    SignInFactorCodeView(factor: .mockResetPasswordEmailCode)
        .environment(\.clerk, .mock)
}

#Preview("Reset Password Phone Code") {
    Container.shared.signInService.preview { @MainActor in
        .init(
            prepareFirstFactor: { _, _, _ in
                try! await Task.sleep(for: .seconds(1))
                return .mock
            },
            attemptFirstFactor: { _, _ in
                try! await Task.sleep(for: .seconds(1))
                return .mock
            }
        )
    }

    SignInFactorCodeView(factor: .mockResetPasswordPhoneCode)
        .environment(\.clerk, .mock)
}

#Preview("TOTP Code") {
    Container.shared.signInService.preview { @MainActor in
        .init(
            attemptSecondFactor: { _, _ in
                try! await Task.sleep(for: .seconds(1))
                return .mock
            }
        )
    }

    SignInFactorCodeView(factor: .mockTotp)
        .environment(\.clerk, .mock)
}

#endif
